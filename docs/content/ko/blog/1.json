{"content":[{"type":"component","name":"Text","props":{"as":"h1","text":"@rvjs/core의 핵심 동작 아이디어","kind":"heading-06"}},{"type":"component","name":"Section","props":{"children":[{"type":"component","name":"Image","props":{"aspectRatio":"1/1","src":"https://github.com/ILikeMintChocolate/rvjs/blob/docs/deploy/docs/content/ko/blog/1.webp?raw=true"}},{"type":"component","name":"Text","props":{"kind":"helper-text-01","color":"textHelper","children":[{"type":"text","name":"text","props":{"text":"내용과 전혀 관련없는 AI로 생성한 이미지입니다."}}]}}]}},{"type":"component","name":"Section","props":{"children":[{"type":"component","name":"Text","props":{"text":"기존 상태 업데이트 방식의 문제","kind":"heading-03","as":"h4"}},{"type":"component","name":"Text","props":{"as":"p","kind":"body-01","children":[{"type":"text","name":"text","props":{"text":"React는 상태가 변경될 때 가상 DOM(Virtual DOM)을 생성하고, 이를 통해 실제 DOM에 반영해야 할 변경 점을 계산합니다. 이 과정에서 변경 점을 비교하기 위해 컴포넌트를 재호출하는 방식이 사용되며, 이는 몇 가지 문제를 동반합니다."}}]}},{"type":"component","name":"OrderedList","props":{"children":[{"type":"component","name":"ListItem","props":{"children":[{"type":"component","name":"Text","props":{"as":"p","kind":"heading-01","children":[{"type":"text","name":"text","props":{"text":"컴포넌트 함수 내부 변수 초기화 문제"}}]}},{"type":"component","name":"Text","props":{"as":"p","kind":"body-01","children":[{"type":"text","name":"text","props":{"text":"컴포넌트 함수 내부에서 선언된 일반 변수는 재호출 시 초기화됩니다. 만약 값을 유지해야 한다면, "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"useRef","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"를 사용하거나 상태로 감싸야 합니다. 하지만 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"useRef","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"는 간단하지만, 코드의 복잡성을 약간 늘릴 수 있고, 상태로 만드는 방식은 불필요한 렌더링을 초래할 가능성이 있어 주의가 필요합니다."}}]}}]}},{"type":"component","name":"ListItem","props":{"children":[{"type":"component","name":"Text","props":{"as":"p","kind":"heading-01","children":[{"type":"text","name":"text","props":{"text":"컴포넌트 재호출을 고려한 코드 작성 강제"}}]}},{"type":"component","name":"Text","props":{"as":"p","kind":"body-01","children":[{"type":"text","name":"text","props":{"text":"React는 모든 코드가 컴포넌트 재호출을 염두에 두고 작성되기를 요구합니다. 인터넷에서 흔히 볼 수 있는 React 클린 코드 기법의 상당수가 결국 컴포넌트 재호출을 고려해야 하는 특성에서 비롯된 것입니다. 이는 개발자가 코드를 작성할 때 재호출의 특성을 항상 의식하도록 강제합니다."}}]}}]}},{"type":"component","name":"ListItem","props":{"children":[{"type":"component","name":"Text","props":{"as":"p","kind":"heading-01","children":[{"type":"text","name":"text","props":{"text":"메모이제이션 기법의 필수성"}}]}},{"type":"component","name":"Text","props":{"as":"p","kind":"body-01","children":[{"type":"text","name":"text","props":{"text":"상태가 변경되면 해당 상태를 선언한 컴포넌트 함수부터 하위 컴포넌트까지 모두 재호출되기 때문에, 불필요한 연산을 방지하려면 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"useMemo","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":", "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"useCallback","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"과 같은 메모이제이션 훅을 사용해야 합니다. 하지만 이러한 기법은 코드 작성의 복잡성을 높이고, 관리 부담을 가중시킵니다."}}]}}]}}]}},{"type":"component","name":"Text","props":{"as":"p","kind":"body-01","children":[{"type":"text","name":"text","props":{"text":"이러한 문제들을 해결하기 위해, 새로운 상태 관리 방식이 필요했습니다. 컴포넌트를 재호출하지 않으면서도 상태와 UI를 효율적으로 연결할 수 있는 접근법이 필요했고, 이에 따라 @rvjs/core는 기존 방식과는 다른 아이디어를 적용하게 되었습니다."}}]}}]}},{"type":"component","name":"Section","props":{"children":[{"type":"component","name":"Text","props":{"text":"새로운 방식의 상태 업데이트","kind":"heading-03","as":"h4"}},{"type":"component","name":"Text","props":{"as":"p","kind":"body-01","children":[{"type":"text","name":"text","props":{"text":"@rvjs/core는 React와 같은 기존 방식에서 발생하는 문제를 해결하기 위해, 상태를 사용하는 요소만 업데이트하는 방식을 도입했습니다. 저는 이를 \"상태 기반 업데이트\"라고 부릅니다. 이 방식에서는 상태가 변경되면 컴포넌트를 재호출하지 않고, 해당 상태를 참조하고 있는 요소만 직접 업데이트합니다."}}]}},{"type":"component","name":"Text","props":{"as":"p","kind":"body-01","children":[{"type":"text","name":"text","props":{"text":""}},{"type":"component","name":"CodeSnippet","props":{"codeText":"setState","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"가 호출되면, 등록된 콜백 함수들이 실행되어 관련된 DOM 요소를 업데이트합니다. 예를 들어, 버튼의 색상이 상태 값에 따라 변경되어야 한다면, 다음과 같은 콜백 함수가 자동으로 등록됩니다."}}]}},{"type":"component","name":"CodeSnippet","props":{"codeText":"const effectFn = () => {\n  buttonElement.style.backgroundColor = currentState();\n};","language":"javascript","type":"multi","width":"100%","defaultShow":true}},{"type":"component","name":"Text","props":{"as":"p","kind":"body-01","children":[{"type":"text","name":"text","props":{"text":""}},{"type":"component","name":"CodeSnippet","props":{"codeText":"useState","href":"#/ko/core-jsx/reactive/useState","language":"javascript","type":"link"}},{"type":"text","name":"text","props":{"text":"는 상태를 관리하면서, 이러한 콜백 함수들을 내부적으로 저장합니다. 중요한 점은 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"useState","href":"#/ko/core-jsx/reactive/useState","language":"javascript","type":"link"}},{"type":"text","name":"text","props":{"text":"는 콜백 함수의 내용을 알 필요 없이, 단순히 함수를 저장하고 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"setState","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":" 호출 시 저장된 모든 함수를 실행하는 역할만 수행한다는 것입니다. 함수가 실행되면 상태 값을 기반으로 필요한 DOM 업데이트가 이루어집니다."}}]}},{"type":"component","name":"Text","props":{"as":"p","kind":"body-01","children":[{"type":"text","name":"text","props":{"text":"이 방식은 가상 DOM(Virtual DOM)과 같은 중간 비교 과정 없이, 변경된 상태를 사용하는 부분만 빠르게 업데이트합니다. 결과적으로, 불필요한 컴포넌트 재호출이나 전체 DOM 비교 없이 효율적으로 UI를 업데이트할 수 있습니다."}}]}}]}},{"type":"component","name":"Section","props":{"children":[{"type":"component","name":"Text","props":{"text":"상태 기반 업데이트 방식의 장점","kind":"heading-03","as":"h4"}},{"type":"component","name":"OrderedList","props":{"children":[{"type":"component","name":"ListItem","props":{"children":[{"type":"component","name":"Text","props":{"as":"p","kind":"heading-01","children":[{"type":"text","name":"text","props":{"text":"불필요한 연산 감소"}}]}},{"type":"component","name":"Text","props":{"as":"p","kind":"body-01","children":[{"type":"text","name":"text","props":{"text":"상태 변경 시 가상 DOM을 사용하지 않으며, 상태를 참조하는 요소만 직접 업데이트합니다. 이에 따라 전체 DOM 비교나 불필요한 렌더링 없이 필요한 부분만 효율적으로 처리할 수 있습니다."}}]}}]}},{"type":"component","name":"ListItem","props":{"children":[{"type":"component","name":"Text","props":{"as":"p","kind":"heading-01","children":[{"type":"text","name":"text","props":{"text":"코드 간소화"}}]}},{"type":"component","name":"Text","props":{"as":"p","kind":"body-01","children":[{"type":"text","name":"text","props":{"text":"컴포넌트 재호출이 없기 때문에, 메모이제이션("}},{"type":"component","name":"CodeSnippet","props":{"codeText":"useMemo","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":", "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"useCallback","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":") 같은 추가적인 최적화 기법이 필요하지 않습니다. 이는 개발자에게 더 단순한 코드 작성 환경을 제공합니다."}}]}}]}},{"type":"component","name":"ListItem","props":{"children":[{"type":"component","name":"Text","props":{"as":"p","kind":"heading-01","children":[{"type":"text","name":"text","props":{"text":"직관적인 업데이트"}}]}},{"type":"component","name":"Text","props":{"as":"p","kind":"body-01","children":[{"type":"text","name":"text","props":{"text":"상태와 UI가 직접 연결되기 때문에, 중간 단계 없이 필요한 부분만 업데이트됩니다. 이는 상태 관리와 UI 업데이트의 흐름을 더욱 직관적으로 만듭니다."}}]}}]}}]}}]}},{"type":"component","name":"Section","props":{"children":[{"type":"component","name":"Text","props":{"text":"상태 기반 업데이트 방식의 한계","kind":"heading-03","as":"h4"}},{"type":"component","name":"OrderedList","props":{"children":[{"type":"component","name":"ListItem","props":{"children":[{"type":"component","name":"Text","props":{"as":"p","kind":"heading-01","children":[{"type":"text","name":"text","props":{"text":"컴파일 단계에서 상태 사용 위치 추적 필요"}}]}},{"type":"component","name":"Text","props":{"as":"p","kind":"body-01","children":[{"type":"text","name":"text","props":{"text":"옵저버 패턴을 사용하기 때문에, 상태를 사용하는 모든 위치를 컴파일 단계에서 미리 찾아야 합니다. 이로 인해 @rvjs/core의 동작은 사실상 컴파일러에 종속될 수밖에 없습니다."}}]}}]}},{"type":"component","name":"ListItem","props":{"children":[{"type":"component","name":"Text","props":{"as":"p","kind":"heading-01","children":[{"type":"text","name":"text","props":{"text":"삭제된 요소에 대한 콜백 호출 문제"}}]}},{"type":"component","name":"Text","props":{"as":"p","kind":"body-01","children":[{"type":"text","name":"text","props":{"text":"특정 상태를 사용하는 DOM 요소가 삭제된 경우에도, 해당 상태 변경 시 콜백 함수가 실행될 수 있습니다. 예를 들어, 상태를 참조하는 요소가 DOM에서 제거된 상황에서 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"setState","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"가 호출되면, 이미 삭제된 요소를 참조하려는 콜백이 실행될 가능성이 있습니다. 이를 방지하기 위해 @rvjs/core는 DOM 요소 또는 컴포넌트가 삭제될 때, 해당 요소와 관련된 콜백 함수를 삭제하는 작업을 수행합니다. 이 과정에서 트리 구조를 순회해야 하며, 약간의 오버헤드가 발생할 수 있습니다. 또한, 사용자는 DOM 요소를 직접 삭제하기보다는, @rvjs/core가 제공하는 삭제 방식을 통해 작업해야 하는 제약이 있습니다."}}]}}]}}]}}]}},{"type":"element","name":"div","props":{"style":{"height":"60vh"}}},{"type":"component","name":"Link","props":{"href":"https://github.com/ILikeMintChocolate/rvjs/blob/docs/deploy/docs/content/ko/blog/1.json","isExternal":true,"children":[{"type":"component","name":"DocumentIcon","props":{"style":{"width":"1rem","filter":"brightness(0) saturate(100%) invert(25%) sepia(69%) saturate(3617%) hue-rotate(218deg) brightness(100%) contrast(104%)"}}},{"type":"component","name":"Text","props":{"text":"Raw Data From Github","color":"linkPrimary"}}]}}]}