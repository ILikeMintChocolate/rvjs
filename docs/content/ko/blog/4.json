{"content":[{"type":"component","name":"Text","props":{"as":"h1","text":"DX 고민하기 | 명확한 규칙 정의","kind":"heading-06"}},{"type":"component","name":"Section","props":{"children":[{"type":"element","name":"div","props":{"style":{"display":"flex","gap":"1rem"},"children":[{"type":"element","name":"div","props":{"style":{"width":"0.25rem","backgroundColor":"#0f62fe"}}},{"type":"component","name":"Text","props":{"text":"이 게시물은 0.2.2 이하 버전인 바닐라 JS에서 동작하는 라이브러리를 만든 경험을 다룹니다.","kind":"helper-text-02"}}]}}]}},{"type":"component","name":"Section","props":{"children":[{"type":"element","name":"img","props":{"style":{"width":"100%"},"src":"https://github.com/ILikeMintChocolate/rvjs/blob/docs/deploy/docs/content/ko/blog/4.png?raw=true"}},{"type":"component","name":"Text","props":{"kind":"helper-text-01","color":"textHelper","children":[{"type":"text","name":"text","props":{"text":"내용과 전혀 관련없는 이미지입니다."}}]}}]}},{"type":"component","name":"Section","props":{"children":[{"type":"component","name":"Text","props":{"as":"p","kind":"body-01","children":[{"type":"text","name":"text","props":{"text":"이전 글 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"\"DX 고민하기 코드 평가 순서 제어\"","href":"#/ko/blog/3","language":"plain","type":"link"}},{"type":"text","name":"text","props":{"text":"에서 반응성을 부여하기 위해 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"dynamic","href":"#/ko/core-js/reactive/dynamic","language":"javascript","type":"link"}},{"type":"text","name":"text","props":{"text":" 함수를 도입한 과정을 소개했습니다. "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"dynamic","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":" 함수는 요소의 속성에 상태를 사용할 경우, 반응성을 부여하는 역할을 합니다."}}]}},{"type":"component","name":"Text","props":{"as":"p","kind":"body-01","children":[{"type":"text","name":"text","props":{"text":"그러나 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"dynamic","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":" 함수만으로는 컴포넌트 개발 시 몇 가지 한계가 있었습니다. 특히, "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"props","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"로 전달할 값의 형태가 모호하다는 점, 컴포넌트 함수가 호출되기 전에 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"props","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"가 먼저 평가되므로 반응성을 부여하기 어렵다는 문제가 있었습니다. 이를 해결하기 위해 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"prop","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":" 함수를 고안했으며, 이 글에서는 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"prop","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":" 함수를 도입한 이유와 그 결과를 소개하겠습니다."}}]}}]}},{"type":"component","name":"Section","props":{"children":[{"type":"component","name":"Text","props":{"text":"기존 방식의 문제점","kind":"heading-03","as":"h4"}},{"type":"component","name":"OrderedList","props":{"children":[{"type":"component","name":"ListItem","props":{"children":[{"type":"component","name":"Text","props":{"as":"p","kind":"heading-compact-01","children":[{"type":"text","name":"text","props":{"text":""}},{"type":"component","name":"CodeSnippet","props":{"codeText":"props","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"로 전달할 값의 형태가 모호함"}}]}},{"type":"component","name":"Text","props":{"as":"p","kind":"body-01","children":[{"type":"text","name":"text","props":{"text":"대부분의 경우, "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"props","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":" 값에는 상태가 사용됩니다. 하지만 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"dynamic","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":" 함수를 어디에서 적용해야 할지가 명확하지 않았습니다."}}]}},{"type":"component","name":"Text","props":{"as":"p","kind":"body-01","children":[{"type":"text","name":"text","props":{"text":"예를 들어, "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"props","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"로 전달되는 값이 상태라면 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"dynamic","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":" 함수를 사용해야 합니다. 그렇다면 컴포넌트 내부에서 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"props","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"를 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"dynamic","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":" 함수로 감싸야 할까요, 아니면 컴포넌트를 사용하는 쪽에서 감싸서 전달해야 할까요?"}}]}},{"type":"component","name":"Text","props":{"as":"p","kind":"body-01","children":[{"type":"text","name":"text","props":{"text":"이러한 모호함으로 인해 개발자는 방어적인 코드를 작성할 수밖에 없었습니다. 즉, "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"props","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":" 값이 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"dynamic","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":" 함수로 감싸져 있는지 확인한 후, 필요하면 다시 감싸는 로직을 추가해야 했습니다."}}]}},{"type":"component","name":"Text","props":{"as":"p","kind":"body-01","children":[{"type":"text","name":"text","props":{"text":"다음은 코드에서 이를 확인할 수 있습니다."}}]}},{"type":"component","name":"CodeSnippet","props":{"codeText":"const NumType = (props) => {\n  return h1({\n    textContent: isDynamic(props.countType)\n      ? props.countType\n      : dynamic(() => props.countType),\n  })\n}","language":"javascript","type":"multi","width":"100%","defaultShow":true}},{"type":"component","name":"Text","props":{"as":"p","kind":"body-01","children":[{"type":"text","name":"text","props":{"text":"이 코드에서는 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"props.countType","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"이 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"dynamic","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":" 함수인지 확인한 후, 그렇지 않다면 감싸는 처리가 필요합니다. 즉, 컴포넌트 내부에서 이를 검사하고 변환해야 하므로 불필요한 코드가 늘어나고, 코드의 일관성이 저해됩니다."}}]}}]}},{"type":"component","name":"ListItem","props":{"children":[{"type":"component","name":"Text","props":{"as":"p","kind":"heading-compact-01","children":[{"type":"text","name":"text","props":{"text":""}},{"type":"component","name":"CodeSnippet","props":{"codeText":"props","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":" 전달 시점의 한계"}}]}},{"type":"component","name":"Text","props":{"as":"p","kind":"body-01","children":[{"type":"text","name":"text","props":{"text":"또한, "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"props","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"를 전달하는 시점에는 반응성을 부여할 수 없습니다."}}]}},{"type":"component","name":"Text","props":{"as":"p","kind":"body-01","children":[{"type":"text","name":"text","props":{"text":"컴포넌트의 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"props","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"는 컴포넌트 함수가 호출되기 전에 먼저 평가됩니다. 따라서 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"props","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"를 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"dynamic","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":" 함수로 감싸더라도 이미 평가된 값을 전달하는 것이므로 반응성이 적용되지 않습니다."}}]}},{"type":"component","name":"Text","props":{"as":"p","kind":"body-01","children":[{"type":"text","name":"text","props":{"text":"다음 코드에서 이를 확인할 수 있습니다."}}]}},{"type":"component","name":"CodeSnippet","props":{"codeText":"const App = () => {\n  const [count, setCount] = useState(0)\n\n  return div({\n    children: [\n      button({\n        textContent: 'Add One',\n        onclick: () => setCount(count() + 1),\n      }),\n      NumType({ countType: count() % 2 === 0 ? '짝수입니다' : '홀수입니다' }),\n    ],\n  })\n}","language":"javascript","type":"multi","width":"100%","defaultShow":true}},{"type":"component","name":"Text","props":{"as":"p","kind":"body-01","children":[{"type":"text","name":"text","props":{"text":"이 코드에서 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"countType","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"은 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"NumType","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"이 실행되기 전에 평가됩니다. 따라서 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"NumType","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":" 내부에서 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"dynamic","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":" 함수를 감싸더라도 이미 평가된 값이기 때문에 반응성을 부여할 수 없습니다."}}]}}]}}]}}]}},{"type":"component","name":"Section","props":{"children":[{"type":"component","name":"Text","props":{"text":"prop 함수 도입","kind":"heading-03","as":"h4"}},{"type":"component","name":"Text","props":{"as":"p","kind":"body-01","children":[{"type":"text","name":"text","props":{"text":"이러한 문제를 해결하기 위해 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"prop","href":"#/ko/core-js/reactive/prop","language":"javascript","type":"link"}},{"type":"text","name":"text","props":{"text":" 함수를 도입했습니다. "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"prop","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":" 함수는 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"props","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"로 전달되는 값을 감싸 반응성을 유지하는 역할을 합니다."}}]}},{"type":"component","name":"Text","props":{"as":"p","kind":"body-01","children":[{"type":"text","name":"text","props":{"text":"기본적인 사용 방식은 다음과 같습니다."}}]}},{"type":"component","name":"CodeSnippet","props":{"codeText":"const App = () => {\n  return NumType({ \n    countType: prop(() => count() % 2 === 0 ? '짝수입니다' : '홀수입니다') \n  })\n}","language":"javascript","type":"multi","width":"100%","defaultShow":true}},{"type":"component","name":"Text","props":{"as":"p","kind":"body-01","children":[{"type":"text","name":"text","props":{"text":"이제 props로 전달하는 값은 prop 함수로 감싸줍니다. 이후 요소의 속성에 적용할 때는 dynamic 함수를 사용합니다."}}]}}]}},{"type":"component","name":"Section","props":{"children":[{"type":"component","name":"Text","props":{"text":"prop 함수의 동작 원리","kind":"heading-03","as":"h4"}},{"type":"component","name":"Text","props":{"as":"p","kind":"body-01","children":[{"type":"text","name":"text","props":{"text":""}},{"type":"component","name":"CodeSnippet","props":{"codeText":"prop","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":" 함수의 핵심 개념은 전달된 값이 상태를 포함하고 있다면 이를 다시 상태로 감싸는 것입니다. 이를 통해 상태가 변경될 때 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"useEffect","href":"#/ko/core-js/reactive/useEffect","language":"javascript","type":"link"}},{"type":"text","name":"text","props":{"text":"를 활용하여 반응성을 유지할 수 있습니다."}}]}},{"type":"component","name":"Text","props":{"as":"p","kind":"body-01","children":[{"type":"text","name":"text","props":{"text":"다음은 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"prop","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":" 함수의 간단한 구현 코드입니다."}}]}},{"type":"component","name":"CodeSnippet","props":{"codeText":"const prop = (fn) => {\n  const value = fn()\n  const states = findIncludeStates()\n  \n  if (states.length) {\n    const [state, setState] = useState(value)\n     useEffect(() => {\n      setState(fn())\n    }, states)\n    return state\n  }\n  \n  return fn\n}","language":"javascript","type":"multi","width":"100%","defaultShow":true}}]}},{"type":"component","name":"Section","props":{"children":[{"type":"component","name":"Text","props":{"text":"기존 방식과 prop 함수 적용 방식 비교","kind":"heading-03","as":"h4"}},{"type":"component","name":"UnorderedList","props":{"children":[{"type":"component","name":"ListItem","props":{"children":[{"type":"component","name":"Text","props":{"as":"p","kind":"heading-compact-01","children":[{"type":"text","name":"text","props":{"text":"기존 방식"}}]}},{"type":"component","name":"CodeSnippet","props":{"codeText":"const NumType = (props) => {\n  return h1({\n    textContent: isDynamic(props.countType)\n      ? props.countType\n      : dynamic(() => props.countType),\n  })\n}","language":"javascript","type":"multi","width":"100%","defaultShow":true}},{"type":"component","name":"Text","props":{"as":"p","kind":"body-01","children":[{"type":"text","name":"text","props":{"text":""}},{"type":"component","name":"CodeSnippet","props":{"codeText":"props.countType","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"이 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"dynamic","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"인지 확인한 후, 필요하면 감싸야 합니다. 모든 컴포넌트에서 이러한 검사가 반복되어 불필요한 코드가 늘어납니다."}}]}}]}},{"type":"component","name":"ListItem","props":{"children":[{"type":"component","name":"Text","props":{"as":"p","kind":"heading-compact-01","children":[{"type":"text","name":"text","props":{"text":""}},{"type":"component","name":"CodeSnippet","props":{"codeText":"prop","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":" 적용 후"}}]}},{"type":"component","name":"CodeSnippet","props":{"codeText":"const NumType = (props) => {\n  return h1({\n    textContent: dynamic(() => props.countType()),\n  })\n}","language":"javascript","type":"multi","width":"100%","defaultShow":true}},{"type":"component","name":"Text","props":{"as":"p","kind":"body-01","children":[{"type":"text","name":"text","props":{"text":""}},{"type":"component","name":"CodeSnippet","props":{"codeText":"prop","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"s 값이 항상 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"prop","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":" 함수로 감싸 전달되므로, 내부에서는 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"dynamic","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":" 함수만 적용하면 됩니다. 불필요한 검사 코드가 사라지고, 일관된 방식으로 반응성을 부여할 수 있습니다."}}]}}]}}]}}]}},{"type":"component","name":"Section","props":{"children":[{"type":"component","name":"Text","props":{"text":"결론","kind":"heading-03","as":"h4"}},{"type":"component","name":"Text","props":{"as":"p","kind":"body-01","children":[{"type":"text","name":"text","props":{"text":""}},{"type":"component","name":"CodeSnippet","props":{"codeText":"prop","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":" 함수는 두 가지 주요 문제를 해결합니다."}}]}},{"type":"component","name":"OrderedList","props":{"children":[{"type":"component","name":"ListItem","props":{"children":[{"type":"component","name":"Text","props":{"as":"span","kind":"body-01","children":[{"type":"text","name":"text","props":{"text":""}},{"type":"component","name":"CodeSnippet","props":{"codeText":"props","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"로 전달되는 값의 형태가 모호했던 문제"}}]}}]}},{"type":"component","name":"ListItem","props":{"children":[{"type":"component","name":"Text","props":{"as":"span","kind":"body-01","children":[{"type":"text","name":"text","props":{"text":""}},{"type":"component","name":"CodeSnippet","props":{"codeText":"props","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"가 먼저 평가되면서 반응성을 부여할 수 없던 문제"}}]}}]}}]}},{"type":"component","name":"Text","props":{"as":"p","kind":"body-01","children":[{"type":"text","name":"text","props":{"text":"이제 개발자는 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"prop","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"s 값을 항상 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"prop","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"으로 감싸기만 하면 반응성을 일관되게 적용할 수 있습니다."}}]}},{"type":"component","name":"Text","props":{"as":"p","kind":"body-01","children":[{"type":"text","name":"text","props":{"text":"그 결과,  컴포넌트 개발이 단순해지고, 불필요한 검사 코드 없이 더 직관적인 구조를 유지할 수 있습니다."}}]}}]}},{"type":"element","name":"div","props":{"style":{"height":"60vh"}}},{"type":"component","name":"Link","props":{"href":"https://github.com/ILikeMintChocolate/rvjs/blob/docs/deploy/docs/content/ko/blog/4.json","isExternal":true,"children":[{"type":"component","name":"DocumentIcon","props":{"style":{"width":"1rem","filter":"brightness(0) saturate(100%) invert(25%) sepia(69%) saturate(3617%) hue-rotate(218deg) brightness(100%) contrast(104%)"}}},{"type":"component","name":"Text","props":{"text":"Raw Data From Github","color":"linkPrimary"}}]}}]}