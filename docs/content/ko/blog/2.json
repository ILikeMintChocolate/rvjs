{"content":[{"type":"component","name":"Text","props":{"as":"h1","text":"useState 구독 관리하기","kind":"heading-06"}},{"type":"component","name":"Section","props":{"children":[{"type":"element","name":"img","props":{"style":{"width":"100%"},"src":"https://github.com/ILikeMintChocolate/rvjs/blob/docs/deploy/docs/content/ko/blog/2.png?raw=true"}},{"type":"component","name":"Text","props":{"kind":"helper-text-01","color":"textHelper","children":[{"type":"text","name":"text","props":{"text":"내용과 전혀 관련없는 AI로 생성한 이미지입니다."}}]}}]}},{"type":"component","name":"Section","props":{"children":[{"type":"component","name":"Text","props":{"as":"p","kind":"body-01","children":[{"type":"text","name":"text","props":{"text":"이전 글 "}},{"type":"component","name":"CodeSnippet","props":{"inline":true,"href":"#/ko/blog/1","codeText":"@rvjs/core의 핵심 동작 아이디어","language":"plain","type":"link"}},{"type":"text","name":"text","props":{"text":"에서 @rvjs/core가 어떻게 상태 기반 업데이트를 활용하는지 설명했었습니다. @rvjs/core는 가상 DOM 없이 상태를 참조하는 요소만 직접 업데이트하는 방식을 사용하며, 이를 통해 불필요한 컴포넌트 재호출을 방지하고 성능을 최적화합니다."}}]}},{"type":"component","name":"Text","props":{"as":"p","kind":"body-01","children":[{"type":"text","name":"text","props":{"text":"이 글에서는 간단한 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"useState","href":"#/ko/core-jsx/reactive/useState","language":"javascript","type":"link"}},{"type":"text","name":"text","props":{"text":" 함수를 만들며, "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"useState","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"가 상태를 어떻게 관리하는지, 그리고 구독을 활용해 UI를 업데이트하는 방식을 살펴보겠습니다. 또, 구독 해제 방식까지 설명하면서 불필요한 업데이트를 방지하는 방법도 함께 이야기해 보겠습니다."}}]}}]}},{"type":"component","name":"Section","props":{"children":[{"type":"component","name":"Text","props":{"text":"useState의 구조","kind":"heading-03","as":"h4"}},{"type":"component","name":"Text","props":{"as":"p","kind":"body-01","children":[{"type":"text","name":"text","props":{"text":"먼저, 가장 단순한 형태의 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"useState","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"를 만들어보겠습니다. 이 함수는 상태 값을 저장하고, 현재 상태를 반환하는 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"getState","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"와 상태를 변경하는 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"setState","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"를 제공합니다."}}]}},{"type":"component","name":"CodeSnippet","props":{"codeText":"const useState = (initialState) => {\n  let state = initialState\n\n  const getState = () => {\n    return state\n  }\n\n  const setState = (newState) => {\n    if (state === newState) {\n      return\n    }\n    state = newState\n  }\n\n  return [state, setState]\n}","language":"javascript","type":"multi","width":"100%","defaultShow":true}},{"type":"component","name":"Text","props":{"as":"p","kind":"body-01","children":[{"type":"text","name":"text","props":{"text":"현재 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"useState","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"는 내부적으로 state 값을 유지하고, "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"getState","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"를 통해 현재 상태를 가져올 수 있도록 합니다. "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"setState","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"가 호출하면 새로운 상태 값으로 업데이트되지만, 값이 동일하면 변경하지 않고 그대로 반환합니다."}}]}}]}},{"type":"component","name":"Section","props":{"children":[{"type":"component","name":"Text","props":{"text":"구독 기능 추가하기","kind":"heading-03","as":"h4"}},{"type":"component","name":"Text","props":{"as":"p","kind":"body-01","children":[{"type":"text","name":"text","props":{"text":"이제 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"getState","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"에서 상태를 참조하는 요소를 추적하고, 이를 구독 형식으로 관리하는 기능을 추가해보겠습니다. 현재 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"getState","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"는 단순히 상태 값을 반환하는 역할만 수행하고, 상태를 참조하는 요소를 추적하지 않기 때문에 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"setState","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"가 호출되더라도 어떤 요소를 업데이트해야 할지 알 수 없습니다. 이를 해결하기 위해, "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"getState","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"가 호출될 때 현재 실행 중인 컨텍스트(컴포넌트나 DOM 요소)를 저장하는 기능을 추가하겠습니다."}}]}},{"type":"component","name":"CodeSnippet","props":{"codeText":"export const stateContext = {\n  context: null,\n}\n\nconst useState = (initialState) => {\n  let state = initialState\n  const subscribes = []\n\n  const getState = () => {\n    if (stateContext.context) {\n      subscribes.push(stateContext.context)\n    }\n    return state\n  }\n\n  const setState = (newState) => {\n    if (state === newState) {\n      return\n    }\n    state = newState\n    for (const subscribe of subscribes) {\n      subscribe()\n    }\n  }\n\n  return [state, setState]\n}","language":"javascript","type":"multi","width":"100%","defaultShow":true}},{"type":"component","name":"Text","props":{"as":"p","kind":"body-01","children":[{"type":"component","name":"CodeSnippet","props":{"codeText":"getState","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"를 호출하면 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"stateContext.context","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"가 존재하는 경우, 이를 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"subscribes","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":" 배열에 추가하여 구독 관계를 설정합니다. 이렇게 하면 특정 상태가 어떤 요소에서 사용되고 있는지를 기록하고, 이후 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"setState","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"가 호출될 때 해당 요소들을 업데이트할 수 있습니다."}}]}},{"type":"component","name":"Text","props":{"as":"p","kind":"body-01","children":[{"type":"text","name":"text","props":{"text":"이 과정을 간단한 예제 코드로 보면 다음과 같습니다."}}]}},{"type":"component","name":"CodeSnippet","props":{"codeText":"const [getCount, setCount] = useState(0)\n\nconst effectFn = () => {\n  element.textContent = `Count: ${getState()}`\n}\n\nstateContext.context = effectFn\neffectFn()\nstateContext.context = null","language":"javascript","type":"multi","width":"100%","defaultShow":true}},{"type":"component","name":"Text","props":{"as":"p","kind":"body-01","children":[{"type":"text","name":"text","props":{"text":"위 코드는 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"getState","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"를 호출하는 시점에 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"stateContext.context","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"에 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"effectFn","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"을 추가한 후 실행하고, 다시 컨텍스트를 초기화하는 방식으로 동작합니다. 이를 통해 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"getState","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":" 내부에서 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"stateContext.context","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"를 감지하고, "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"subscribes","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":" 배열에 추가할 수 있습니다."}}]}},{"type":"component","name":"Text","props":{"as":"p","kind":"body-01","children":[{"type":"text","name":"text","props":{"text":"이 과정은 사용자가 직접 관리하는 것이 아니라, 내부적으로 자동으로 처리됩니다. 사용자는 단순히 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"getState","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"를 호출하는 것만으로도 실행 중인 컨텍스트가 자동으로 구독되며, 이후 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"setState","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"가 호출되면 적절한 UI 업데이트가 이루어집니다."}}]}}]}},{"type":"component","name":"Section","props":{"children":[{"type":"component","name":"Text","props":{"text":"구독 실행 순서 제어하기","kind":"heading-03","as":"h4"}},{"type":"component","name":"Text","props":{"as":"p","kind":"body-01","children":[{"type":"text","name":"text","props":{"text":"현재 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"subscribes","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"는 단순한 배열로 관리되며, 상태를 참조하는 모든 콜백이 같은 배열에 저장되는 구조입니다. 하지만 이렇게 되면 DOM을 업데이트하는 콜백, "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"useEffect","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"를 호출하는 콜백, 기본적인 컴포넌트 업데이트를 담당하는 콜백 등이 섞여 실행 순서를 제어하기 어려워집니다."}}]}},{"type":"component","name":"Text","props":{"as":"p","kind":"body-01","children":[{"type":"text","name":"text","props":{"text":"예를 들어, DOM 업데이트는 즉시 실행되어야 하지만, "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"useEffect","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"는 다음 렌더링 사이클에서 실행될 수도 있습니다. 또한, "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"For","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":", "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"Switch/Case","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":", "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"Toggle","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"과 같은 구조적인 컴포넌트의 업데이트는 별도로 관리하는 것이 좋습니다. 이를 해결하기 위해, "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"subscribes","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"를 단순 배열이 아닌 목적별로 구분된 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"Set","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":" 객체로 관리하도록 수정하겠습니다."}}]}},{"type":"component","name":"CodeSnippet","props":{"codeText":"const useState = (initialState) => {\n  let state = initialState\n  const subscribes = {\n    DOM_EFFECT: new Set(),\n    USE_EFFECT: new Set(),\n    FLOW_EFFECT: new Set(),\n  }\n\n  const getState = () => {\n    if (stateContext.context) {\n      const { type, effectFn } = stateContext.context\n      subscribes[type].add(effectFn)\n    }\n    return state\n  }\n\n  const setState = (newState) => {\n    if (state === newState) {\n      return\n    }\n    state = newState\n    for (const effect of subscribes.DOM_EFFECT) {\n      effect()\n    }\n    for (const effect of subscribes.USE_EFFECT) {\n      effect()\n    }\n    for (const effect of subscribes.FLOW_EFFECT) {\n      effect()\n    }\n  }\n\n  return [state, setState]\n}","language":"javascript","type":"multi","width":"100%","defaultShow":true}},{"type":"component","name":"Text","props":{"as":"p","kind":"body-01","children":[{"type":"text","name":"text","props":{"text":"이제 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"subscribes","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"는 단순 배열이 아니라, 각 목적별로 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"DOM_EFFECT","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":", "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"USE_EFFECT","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":", "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"FLOW_EFFECT","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"라는 Set 객체에 구독을 저장하는 방식으로 개선되었습니다."}}]}},{"type":"component","name":"UnorderedList","props":{"children":[{"type":"component","name":"ListItem","props":{"children":[{"type":"element","name":"div","props":{"style":{"display":"grid","gridTemplateColumns":"20% 80%"},"children":[{"type":"component","name":"Text","props":{"as":"p","kind":"body-01","children":[{"type":"component","name":"CodeSnippet","props":{"codeText":"DOM_EFFECT","language":"javascript","type":"inline"}}]}},{"type":"component","name":"Text","props":{"as":"p","kind":"body-01","children":[{"type":"text","name":"text","props":{"text":"DOM을 업데이트하는 콜백들이 저장됩니다."}}]}}]}}]}},{"type":"component","name":"ListItem","props":{"children":[{"type":"element","name":"div","props":{"style":{"display":"grid","gridTemplateColumns":"20% 80%"},"children":[{"type":"component","name":"Text","props":{"as":"p","kind":"body-01","children":[{"type":"component","name":"CodeSnippet","props":{"codeText":"USE_EFFECT","language":"javascript","type":"inline"}}]}},{"type":"component","name":"Text","props":{"as":"p","kind":"body-01","children":[{"type":"component","name":"CodeSnippet","props":{"codeText":"useEffect","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"와 같은 사이드 이펙트 관련 콜백이 저장됩니다."}}]}}]}}]}},{"type":"component","name":"ListItem","props":{"children":[{"type":"element","name":"div","props":{"style":{"display":"grid","gridTemplateColumns":"20% 80%"},"children":[{"type":"component","name":"Text","props":{"as":"p","kind":"body-01","children":[{"type":"component","name":"CodeSnippet","props":{"codeText":"FLOW_EFFECT","language":"javascript","type":"inline"}}]}},{"type":"component","name":"Text","props":{"as":"p","kind":"body-01","children":[{"type":"component","name":"CodeSnippet","props":{"codeText":"For","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":", "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"Switch/Case","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":", "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"Toggle","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":" 등의 구조적인 업데이트를 담당하는 콜백이 저장됩니다."}}]}}]}}]}}]}},{"type":"component","name":"Text","props":{"as":"p","kind":"body-01","children":[{"type":"text","name":"text","props":{"text":"이렇게 하면 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"setState","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"가 호출될 때, 각 구독 유형을 분리하여 실행할 수 있으며, 실행 순서를 제어하기도 더 쉬워집니다. 예를 들어, 먼저 DOM 업데이트를 수행한 후, "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"useEffect","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"를 실행하고, 마지막으로 구조적인 업데이트를 처리하는 방식으로 동작하게 됩니다."}}]}},{"type":"component","name":"Text","props":{"as":"p","kind":"body-01","children":[{"type":"text","name":"text","props":{"text":"또한, 기존 배열 대신 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"Set","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"을 사용하여 구독을 관리하도록 변경했습니다. "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"Set","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"을 사용하면 중복된 콜백이 저장되지 않으며, 특정 구독을 해제할 때도 쉽게 삭제할 수 있습니다."}}]}}]}},{"type":"component","name":"Section","props":{"children":[{"type":"component","name":"Text","props":{"text":"구독을 해제하는 이유","kind":"heading-03","as":"h4"}},{"type":"component","name":"Text","props":{"as":"p","kind":"body-01","children":[{"type":"text","name":"text","props":{"text":"현재 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"useState","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"는 상태를 구독하는 요소를 추적하여, "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"setState","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"가 호출될 때 관련된 UI를 업데이트하도록 설계되었습니다. 하지만 상태를 구독하던 요소가 삭제될 경우, 구독 정보를 정리하지 않으면 문제가 발생할 수 있습니다. 구독 해제가 없으면, 삭제된 요소가 여전히 상태를 구독하고 있기 때문에 존재하지 않는 요소를 업데이트하려는 시도가 발생합니다."}}]}},{"type":"component","name":"Text","props":{"as":"p","kind":"body-01","children":[{"type":"text","name":"text","props":{"text":"이를 예제로 확인해보겠습니다."}}]}},{"type":"component","name":"CodeSnippet","props":{"codeText":"const App = () => {\n  const [show, setShow] = useState(false)\n  const [count, setCount] = useState(0)\n\n  return (\n    <div>\n      <button onClick={() => setShow(!show())}>Toggle</button>\n      <button onClick={() => setCount(count() + 1)}>+1</button>\n      <Toggle is={show()}>\n        <Content count={count()} />\n      </Toggle>\n    </div>\n  )\n}\n\nconst Content = (props) => {\n  return <p>Count: {props.count}</p>\n}","language":"jsx","type":"multi","width":"100%","defaultShow":true}},{"type":"component","name":"Text","props":{"as":"p","kind":"body-01","children":[{"type":"text","name":"text","props":{"text":"위 코드를 실행하면 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"show","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":" 상태가 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"true → false","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"로 변경될 때 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"Content","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":" 컴포넌트가 제거됩니다. 하지만 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"Content","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":" 내부의 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"p","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":" 태그는 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"count","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":" 상태를 구독하고 있기 때문에, 구독 해제 기능이 없으면 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"setCount","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"가 호출될 때 이미 DOM에서 삭제된 요소를 업데이트하려는 시도가 이루어집니다."}}]}},{"type":"component","name":"Text","props":{"as":"p","kind":"body-01","children":[{"type":"text","name":"text","props":{"text":"이 과정에서 브라우저는 존재하지 않는 요소의 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"textContent","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"를 변경하려고 시도할 수 있고, 이미 DOM에서 해제된 요소를 불필요하게 업데이트할 수도 있습니다. 또한, 요소가 화면에서 사라졌다고 해도, 해당 요소의 참조가 남아있어 브라우저의 가비지 컬렉션(GC)은 해당 요소를 정리하지 못합니다. 애플리케이션이 장시간 실행되면서 구독이 계속 누적되면, 사용되지 않는 메모리가 점점 증가해 성능 저하로 이어질 수 있습니다."}}]}}]}},{"type":"component","name":"Section","props":{"children":[{"type":"component","name":"Text","props":{"text":"구독 해제하기","kind":"heading-03","as":"h4"}},{"type":"component","name":"Text","props":{"as":"p","kind":"body-01","children":[{"type":"text","name":"text","props":{"text":"상태를 구독하는 요소가 제거될 때 구독 정보를 정리하지 않으면, 삭제된 요소를 업데이트하려는 불필요한 연산이 발생하고, 참조가 남아 있어 메모리 누수가 발생할 수 있습니다. 이를 방지하기 위해 컴포넌트가 삭제될 때 해당 상태의 구독도 함께 해제하는 기능을 추가해야 합니다."}}]}},{"type":"component","name":"Text","props":{"as":"p","kind":"body-01","children":[{"type":"text","name":"text","props":{"text":"다음은 구독 해제 기능이 포함된 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"useState","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"의 코드입니다."}}]}},{"type":"component","name":"CodeSnippet","props":{"codeText":"const useState = (initialState) => {\n  let state = initialState\n  const subscribes = {\n    DOM_EFFECT: new Set(),\n    USE_EFFECT: new Set(),\n    FLOW_EFFECT: new Set(),\n  }\n\n  const getState = () => {\n    if (stateContext.context) {\n      const { type, component, effectFn } = stateContext.context\n      subscribes[type].add(effectFn)\n      if (component) {\n        component.unsubscribeEffectHandlers.push(() => {\n          subscribes[type].delete(effectFn)\n        })\n      }\n    }\n    return state\n  }\n\n  const setState = (newState) => {\n    if (state === newState) {\n      return\n    }\n    state = newState\n    for (const effect of subscribes.DOM_EFFECT) {\n      effect()\n    }\n    for (const effect of subscribes.USE_EFFECT) {\n      effect()\n    }\n    for (const effect of subscribes.FLOW_EFFECT) {\n      effect()\n    }\n  }\n\n  return [state, setState]\n}","language":"jsx","type":"multi","width":"100%","defaultShow":true}},{"type":"component","name":"Text","props":{"as":"p","kind":"body-01","children":[{"type":"text","name":"text","props":{"text":"컴포넌트는 서로 트리 구조로 연결되어 있으며, 부모-자식 관계를 형성합니다. 따라서 컴포넌트가 삭제될 때, 해당 컴포넌트뿐만 아니라 모든 하위 컴포넌트도 함께 삭제됩니다. 이 과정에서, 각 컴포넌트는 구독 해제 콜백 함수들을 저장하고 있고, 삭제될 때 이를 실행하여 상태 구독을 해제하게 됩니다."}}]}}]}},{"type":"element","name":"div","props":{"style":{"height":"60vh"}}},{"type":"component","name":"Link","props":{"href":"https://github.com/ILikeMintChocolate/rvjs/blob/docs/deploy/docs/content/ko/blog/2.json","isExternal":true,"children":[{"type":"component","name":"DocumentIcon","props":{"style":{"width":"1rem","filter":"brightness(0) saturate(100%) invert(25%) sepia(69%) saturate(3617%) hue-rotate(218deg) brightness(100%) contrast(104%)"}}},{"type":"component","name":"Text","props":{"text":"Raw Data From Github","color":"linkPrimary"}}]}}]}