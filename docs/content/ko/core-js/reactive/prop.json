{"content":[{"type":"component","name":"Text","props":{"as":"h1","text":"prop","kind":"heading-06"}},{"type":"component","name":"Section","props":{"children":[{"type":"component","name":"Text","props":{"children":[{"type":"text","name":"text","props":{"text":"컴포넌트의 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"props","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"를 효율적으로 전달하기 위한 함수입니다."}}]}},{"type":"component","name":"Text","props":{"children":[{"type":"component","name":"CodeSnippet","props":{"codeText":"prop","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":" 함수는 기능을 구현하기 위한 필수 규칙은 아닙니다. 그러나 여러 문제를 해결하고자 고안된 도움 함수인 만큼, 효율적인 컴포넌트 구현을 위한 권장사항입니다."}}]}}]}},{"type":"component","name":"Section","props":{"children":[{"type":"component","name":"Text","props":{"text":"예시","kind":"heading-03","as":"h4"}},{"type":"component","name":"Iframe","props":{"src":"https://rvjs.xyz/example/core-js/reactive/prop/ex1/"}},{"type":"component","name":"CodeSnippet","props":{"codeText":"import { button, dynamic, prop, Prop } from '@rvjs/core'\n\nconst App = () => {\n  return Button({\n    text: prop(() => 'Click me'),\n    onclick: () => alert('Hello world!'),\n  })\n}\n\ninterface ButtonProps {\n  text: Prop<string>\n  bgColor?: Prop<'white' | 'red' | 'blue'>\n  onclick: GlobalEventHandlers['onclick']\n}\n\nconst Button = (props: ButtonProps) => {\n  const { text, bgColor = prop(() => 'white'), onclick } = props\n\n  return button({\n    textContent: dynamic(() => text()),\n    style: {\n      backgroundColor: dynamic(() => bgColor()),\n    },\n    onclick,\n  })\n}\n\nexport default App","language":"javascript","type":"multi","width":"100%","defaultShow":true}}]}},{"type":"component","name":"Section","props":{"children":[{"type":"component","name":"Text","props":{"text":"레퍼런스","kind":"heading-03","as":"h4"}},{"type":"component","name":"CodeSnippet","props":{"codeText":"function prop<T>(valueFn: () => T): PropFn<T> | GetState<T>","language":"typescript","type":"single","width":"100%","defaultShow":true}},{"type":"component","name":"Text","props":{"text":"매개변수","kind":"heading-compact-01"}},{"type":"component","name":"UnorderedList","props":{"children":[{"type":"component","name":"ListItem","props":{"children":[{"type":"element","name":"div","props":{"style":{"display":"grid","gridTemplateColumns":"20% 80%"},"children":[{"type":"component","name":"Text","props":{"children":[{"type":"component","name":"CodeSnippet","props":{"codeText":"valueFn","language":"javascript","type":"inline"}}],"as":"span"}},{"type":"component","name":"Text","props":{"children":[{"type":"text","name":"text","props":{"text":"콜백 함수 형태로 값을 반환합니다."}}],"as":"span"}}]}}]}}]}},{"type":"component","name":"Text","props":{"text":"반환 값","kind":"heading-compact-01"}},{"type":"component","name":"UnorderedList","props":{"children":[{"type":"component","name":"ListItem","props":{"children":[{"type":"element","name":"div","props":{"style":{"display":"grid","gridTemplateColumns":"20% 80%"},"children":[{"type":"component","name":"Text","props":{"children":[{"type":"component","name":"CodeSnippet","props":{"codeText":"PropFn<T>","language":"javascript","type":"inline"}}],"as":"span"}},{"type":"component","name":"Text","props":{"children":[{"type":"component","name":"CodeSnippet","props":{"codeText":"valueFn","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":" 내부에서 상태를 사용하지 않았을 경우, "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"valueFn","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"을 그대로 반환합니다."}}],"as":"span"}}]}}]}},{"type":"component","name":"ListItem","props":{"children":[{"type":"element","name":"div","props":{"style":{"display":"grid","gridTemplateColumns":"20% 80%"},"children":[{"type":"component","name":"Text","props":{"children":[{"type":"component","name":"CodeSnippet","props":{"codeText":"GetState<T>","language":"javascript","type":"inline"}}],"as":"span"}},{"type":"component","name":"Text","props":{"children":[{"type":"component","name":"CodeSnippet","props":{"codeText":"valueFn","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":" 내부에서 상태를 사용한다면, 상태에 의존하는 새로운 상태를 만들어 반환합니다."}}],"as":"span"}}]}}]}}]}}]}},{"type":"component","name":"Section","props":{"children":[{"type":"component","name":"Text","props":{"text":"사용법","kind":"heading-03","as":"h4"}},{"type":"component","name":"Text","props":{"children":[{"type":"text","name":"text","props":{"text":"컴포넌트에 전달할 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"props","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":" 중 아래 경우를 제외하고는 모두 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"prop","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":" 함수로 감싸 전달합니다. 컴포넌트 내부에서는 요소의 속성에 전달할 때, 전달받은 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"props","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"를 모두 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"dynamic","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":" 함수에 감싸 전달합니다. 컴포넌트 입장에서는 모든 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"props","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"를 함수 형태로 전달받게 됨으로 타입의 일관성을 유지할 수 있습니다."}}]}}]}},{"type":"component","name":"Section","props":{"children":[{"type":"component","name":"Text","props":{"text":"prop 함수를 사용하지 않는 경우","kind":"heading-03","as":"h4"}},{"type":"component","name":"UnorderedList","props":{"children":[{"type":"component","name":"ListItem","props":{"children":[{"type":"component","name":"Text","props":{"children":[{"type":"text","name":"text","props":{"text":"상태를 직접 전달하는 경우"}}]}},{"type":"component","name":"CodeSnippet","props":{"codeText":"const App = () => {\n  const [text, setText] = useState('Click me')\n\n  return Button({\n    text: text,\n    onclick: () => alert('Hello world!'),\n  })\n}","language":"javascript","type":"multi","width":"100%","defaultShow":true}}]}},{"type":"component","name":"ListItem","props":{"children":[{"type":"component","name":"Text","props":{"children":[{"type":"text","name":"text","props":{"text":"이벤트 등록, 특정 로직을 위한 핸들러 함수"}}]}}]}}]}}]}},{"type":"component","name":"Section","props":{"children":[{"type":"component","name":"Text","props":{"text":"도입 배경 1","kind":"heading-03","as":"h4"}},{"type":"component","name":"Text","props":{"children":[{"type":"component","name":"CodeSnippet","props":{"codeText":"@rvjs/core","language":"javascript","type":"link","href":"#/ko/core-js/overview/gettingStarted"}},{"type":"text","name":"text","props":{"text":"는 상태 변경 시 실제 값이 사용된 부분만 리렌더링하여 성능을 최적화합니다. 이러한 동작을 구현하기 위해 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"useState","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"의 첫 번째 반환 값인 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"getState","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"를 함수로 만들었습니다. 아래 예시에서 알 수 있듯이 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"getCount","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"는 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"() ⇒ number","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":" 타입입니다."}}]}},{"type":"component","name":"Text","props":{"children":[{"type":"text","name":"text","props":{"text":"이러한 방식은 컴포넌트를 생성하고 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"props","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"를 전달하는 과정에서 혼란을 야기할 수 있습니다. 예를 들어, "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"text","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"를 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"props","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"로 전달받는 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"Text","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":" 컴포넌트를 구현해 보겠습니다. 아래에서 알 수 있듯이 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"text","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"는 값이 문자열인지, 상태 값을 반환하는 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"getState","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":" 함수인지 구별하기 위해 다음과 같은 조건부 로직을 필수적으로 사용해야 했습니다."}}]}},{"type":"component","name":"CodeSnippet","props":{"codeText":"const Text = (props) => {\n  const { text } = props\n\n  return p({\n    textContent: dynamic(() => (isGetState(text) ? text() : text)),\n  })\n}","language":"javascript","type":"multi","width":"100%","defaultShow":true}},{"type":"component","name":"Text","props":{"children":[{"type":"text","name":"text","props":{"text":"이러한 조건부 로직은 전달받는 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"props","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"의 개수가 늘어날수록 가독성이 떨어지고, "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"props","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"를 사용하는 모든 상황에서 필수적으로 사용되어야 했기에 다른 방식을 고안할 필요가 있었습니다."}}]}}]}},{"type":"component","name":"Section","props":{"children":[{"type":"component","name":"Text","props":{"text":"도입 배경 2","kind":"heading-03","as":"h4"}},{"type":"component","name":"Text","props":{"children":[{"type":"text","name":"text","props":{"text":"상태를 직접 넘기는 상황이 아닌, 상태에 기반한 값을 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"props","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"로 넘기는 경우에 대응하기 어려운 점도 있었습니다. 예를 들어, "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"count","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":" 상태가 짝수인지 홀수인지에 따라 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"Text","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":" 컴포넌트에 다른 문자열을 전달해야 하는 상황이 있을 수 있습니다. "}}]}},{"type":"component","name":"CodeSnippet","props":{"codeText":"const Text = (props) => {\n  const { text } = props\n\n  return p({\n    textContent: text,\n  })\n}\n\nconst Counter = () => {\n  const [count, setCount] = useState(0)\n\n  // 반응성을 가지긴 하지만, 짝수 홀수 여부를 출력하라는 요구사항에 맞지 않음\n  const case1 = Text({\n    text: count,\n  })\n\n  // 짝수 홀수 여부를 출력하지만, 반응성을 가지지 않음\n  const case2 = Text({\n    text: count() % 2 === 0 ? '짝수입니다' : '홀수입니다',\n  })\n\n  // 요구사항도 만족하고 반응성도 가지지만,\n  // Text 컴포넌트 내부에서 dynamic 함수의 반환 함수인지 확인하는 로직 필요\n  const case3 = Text({\n    text: dynamic(() => (count() % 2 === 0 ? '짝수입니다' : '홀수입니다')),\n  })\n}\n","language":"javascript","type":"multi","width":"100%","defaultShow":true}},{"type":"component","name":"Text","props":{"children":[{"type":"text","name":"text","props":{"text":"이 상황에서 반응성도 가지고, 요구사항도 만족하는 방식은 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"case3","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"입니다. 언뜻 보기에 문제가 해결된 것처럼 보입니다. 그러나 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"Text","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":" 컴포넌트는 범용성 측면에서 큰 문제를 가지고 있습니다. 만약 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"string","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":" 타입의 문자열을 출력하는 상황, 반응성을 가지도록 상태를 사용해 출력하는 상황, 위 예시처럼 상태에 기반한 새로운 문자열을 출력하는 상황에서 모두 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"Text","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":" 컴포넌트를 사용할 수 있을까요? 이러한 모든 요구사항을 만족하는 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"Text","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"를 만들기 위해서는 아래와 같이 복잡한 조건부 로직이 필요합니다."}}]}},{"type":"component","name":"CodeSnippet","props":{"codeText":"const Text = (props) => {\n  const { text } = props\n\n  return p({\n    textContent: isDynamic(text) ? text : isGetState(text) ? text() : text\n  })\n}","language":"javascript","type":"multi","width":"100%","defaultShow":true}},{"type":"component","name":"Text","props":{"children":[{"type":"text","name":"text","props":{"text":"첫 번째 도입 배경과 마찬가지로 상태에 기반한 값에 반응성을 부여하기 위해서는, 파생되는 여러 규칙이 필요해지고, 컴포넌트에서는 어떤 타입의 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"props","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"를 받을지 확신할 수 없기 때문에 모든 상황에 대응하는 방어적인 코드를 작성해야 합니다."}}]}},{"type":"component","name":"Text","props":{"children":[{"type":"text","name":"text","props":{"text":"이러한 문제를 해결하고자 일관적인 형태의 값을 전달받기 위한 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"prop","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":" 함수가 만들어지게 되었습니다."}}]}}]}},{"type":"component","name":"Section","props":{"children":[{"type":"component","name":"Text","props":{"text":"사용 이점","kind":"heading-03","as":"h4"}},{"type":"component","name":"UnorderedList","props":{"children":[{"type":"component","name":"ListItem","props":{"children":[{"type":"element","name":"div","props":{"style":{"display":"grid","gridTemplateColumns":"20% 80%"},"children":[{"type":"component","name":"Text","props":{"children":[{"type":"text","name":"text","props":{"text":"일관된 타입 처리"}}],"as":"span"}},{"type":"component","name":"Text","props":{"children":[{"type":"text","name":"text","props":{"text":"모든 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"props","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"를 함수로 감싸 전달하므로, 컴포넌트 내부에서 타입을 구분할 필요 없이 일관되게 처리할 수 있습니다."}}],"as":"span"}}]}}]}},{"type":"component","name":"ListItem","props":{"children":[{"type":"element","name":"div","props":{"style":{"display":"grid","gridTemplateColumns":"20% 80%"},"children":[{"type":"component","name":"Text","props":{"children":[{"type":"text","name":"text","props":{"text":"상태 변화 감지"}}],"as":"span"}},{"type":"component","name":"Text","props":{"children":[{"type":"component","name":"CodeSnippet","props":{"codeText":"prop","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":" 함수는 내부적으로 상태 변화를 감지하여, 해당 상태가 변경될 때 컴포넌트를 자동으로 리렌더링하도록 합니다."}}],"as":"span"}}]}}]}},{"type":"component","name":"ListItem","props":{"children":[{"type":"element","name":"div","props":{"style":{"display":"grid","gridTemplateColumns":"20% 80%"},"children":[{"type":"component","name":"Text","props":{"children":[{"type":"text","name":"text","props":{"text":"코드 가독성 향상"}}],"as":"span"}},{"type":"component","name":"Text","props":{"children":[{"type":"text","name":"text","props":{"text":"복잡한 조건부 로직 없이 간결하게 "}},{"type":"component","name":"CodeSnippet","props":{"codeText":"props","language":"javascript","type":"inline"}},{"type":"text","name":"text","props":{"text":"를 처리할 수 있어 코드의 가독성이 향상됩니다."}}],"as":"span"}}]}}]}}]}}]}},{"type":"element","name":"div","props":{"style":{"height":"60vh"}}},{"type":"component","name":"Link","props":{"href":"https://github.com/ILikeMintChocolate/rvjs/blob/docs/deploy/docs/content/ko/core-js/reactive/prop.json","isExternal":true,"children":[{"type":"component","name":"DocumentIcon","props":{"style":{"width":"1rem","filter":"brightness(0) saturate(100%) invert(25%) sepia(69%) saturate(3617%) hue-rotate(218deg) brightness(100%) contrast(104%)","z-index":"-1"}}},{"type":"component","name":"Text","props":{"text":"Raw Data From Github","color":"linkPrimary"}}]}}]}